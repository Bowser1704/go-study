# Go语言学习笔记

## 基础

### 变量声明

```go
i := 1
//短变量声明，只能用于函数内部，不能用于包级变量
//在for循环体内的initialization只能使用这种方法来声明变量
//短变量声明最少必须要声明一个变量，已经声明过得实际上是赋值行为，必须是当前词法域

var s string
//初始化为类型的初值

var s = ""
//根据初值，自动判断类型

var i uint32 = 1
//手动设置类型，并且给初值，默认判断类型会有疑问，例如1到底是什么类型，int？uint32？int64？。Go是强类型语言，所有类型都不能自动转换。
```

所以短变量的申明的默认初始类型是什么呢？

```go
import ."reflect"

i := 1
//TypeOf(i) == int
f := 1.0
//TypeOf(f) == float64

//要明确这个，否则会有下面的错误.
var i uint64 = 1;
a := 0
a = i //错误，不能隐式uint64转int
```

### 作用域

首先作用域与生命周期是两个东西，后者是变量存活的时间，特别是go这种带gc的。

代码块指定了作用域，句法块内部声明的名字是无法被外部块访问的。存在一个整体的词法块，称为全局词法块；即有一个全局作用域。**编译器看到一个名字是会从内部作用域向外(全局)作用域查找的**。

像类似for循环，if和switch语句，会在条件部分创建隐式词法域，也就是说其实有两个词法域，条件部分，循环体/执行体部分，前者在后者的外部(也就是后面的可以访问前面的)

```go
//容易犯的错误
var cwd string

func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    //如果是短变量声明，他在本地作用域没有发现cwd这个变量，那就会自己声明一个，而不是cwd是赋值行为。
    /*修改为
    var err error
    cwd, err = os.Getwd()
    */
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```



## net相关

### 小问题

1. 为什么**Response.Body**每次都要手动关闭。

   底层的实现是当Body被读完之后，即读到EOF就会自动关闭Body，但是没有读完的话，是不会关闭的。